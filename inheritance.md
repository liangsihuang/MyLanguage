# inheritance

为什么类的初始化，两边类型不同？public 继承的赋值兼容规则

`LinearSOE * theSOE = new BandSPDLinSOE( * theSolver);`

## C++ inheritance and derived class

默认是 public 继承 `class DeriveClassName : public BaseClassName {}`

* 派生类的对象可以赋值给基类对象！实现多态的一个关键！
* 派生类对象可以初始化基类引用
* 派生类对象的地址可以赋值给基类指针

派生类拥有基类的所有成员变量和函数（无论 private, protected, public）

* 但是派生类的成员函数，不能访问基类的 private 成员
* 可以访问基类的 protected 成员

成员函数可以覆盖，覆盖以后还可以调用基类的同名函数

* `BaseClassName:: Func`

## C++ polymorphism

多态的实现：虚函数

1. 编译时，给有虚函数的对象增加一个4字节的指针，指向该类（基类）的虚函数表，虚函数表存放该类所有虚函数的地址
2. 编译时，不确定调用基类还是某一个派生类的函数
3. 运行时，将某派生类的对象赋值给基类对象，则调用该派生类的函数
4. 运行时，将基类的对象赋值给基类，则调用基类的函数
5. 如果把基类设置为纯虚类（包含纯虚函数），没有4，基类变成只是提供接口

多态的弊端：增加运行时的时间（查虚函数表）和空间（存储4字节的指针）开销

python 没有静态类型检查，也就没有虚函数，没有多态

## python inheritance

python 的继承只是代码重用，不是多态

函数调用（包括构造函数）

* 首先在派生类中查找，再从基类（多继承则从左到右）中查找

调用父类同名函数

* 父类名. 函数名\(self, 参数\)
* super\(\). 函数名\(参数\)
* 推荐使用 super\(\)，一是父类名改变也无需修改，二是不用显示传递self
* 但是，多继承下只能用父类名来区分不同父类的构造函数，要显示传递self！

## 多继承

C++ 和 python 都支持

